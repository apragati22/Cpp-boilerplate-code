{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"Starting": {
	"prefix": "boilerplate code",
	 	"body": [
			"#include<bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp> ",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace std;\n",

			"#define ll long long",
			"#define ld long double",
			"#define llmax 9223372036854775807",
			"#define llmin -9223372036854775808",
			"#define IM INT_MAX",
			"#define im INT_MIN",
			"#define all(x) (x).begin(), (x).end()",
			"#define fi first",
			"#define sec second",
			"#define pii pair<int, int>",
			"#define pll pair<ll, ll>",
			
			"#define pb push_back",
			"#define mk make_pair",
			"#define vi vector<int>",
			"#define vll vector<ll>",
			"#define endl '\\n'",
			"#define fr(i,l,r) for(ll i=l;i<r;i++)",
			"#define eqfr(i,l,r) for(ll i=l;i<=r;i++)",
			"#define bkfr(i,l,r) for(ll i=r-1;i>=l;i--)",
			"#define frit(it,end,v) {for(it = v.begin(); it!=end; it++) cout<< *it<<\" \"; cout<<endl;}",
			
			"#define ordered_set tree<ll, null_type,less<ll>, rb_tree_tag,tree_order_statistics_node_update>",
			"using namespace __gnu_pbds;",
			
			"void yes() { cout<<\"YES\\n\"; }",
			"void no() { cout<<\"NO\\n\"; }",
			"bool prime(ll a) { if (a==1) return 0; for (ll i=2;i<=round(sqrt(a));i++) if (a%i==0) return 0; return 1; }",
			"ll gcd(ll a,ll b) { if (b==0) return a; else return gcd(b,a%b); }",
			"ll lcm(ll a,ll b) { return a/gcd(a,b)*b; }\n",

			"inline ll nxt() { ll x; cin >> x; return x; }\n",

			"ll bf (vector<vector<pair<ll,ll>>>& g, ll src, ll snk, vector<ll>& dp, ll &n, ll &m){",
				"for(ll i=1; i<=n; i++) dp[i]=1e9;",
				"dp[src]=0;",
				"for(auto i:g[src]) dp[i.first]=i.second;",
				"for(ll t=2; t<=m ;t++){",
					"vector<ll> newdp(n+1);",
					"for(ll i=1; i<=n; i++){",
						"newdp[i]=dp[i];",
						"for(auto k:g[i]){ // use that list here",
							"newdp[i]=min(newdp[i], dp[k.first]+k.second);",
						"}",
					"}",
					"if(dp==newdp) break;",
					"dp=newdp;",
				"}",
				"return dp[n];",
			"}\n\n",

			"void dfs_ap(vector<int> adj[], vector<int>& dfn, vector<int>& vis, vector<int>& par, int i, set<int>& ans, vector<int>& hp, int n){",
				"vis[i]=1;",
				"dfn[i]=n++;",
				"for(auto j:adj[i]){",
					"if(vis[j]==0){",
						"par[j]=i;",
						"dfs_ap(adj, dfn, vis, par, j, ans, hp, n);",
						"hp[i]=min(hp[i], hp[j]);",
						"if(hp[j]>=dfn[i] && i!=0) ans.insert(i);",
					"}",
					"else if(j!=par[i]) hp[i]=min(hp[i], dfn[j]);",
			"}}\n\n",

			"void dijkstra(vector<pair<int, int>> adj_list[], vector<int> shortest_distances, int source_vertex, int destination_vertex){",
				"priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
				"pq.push({0, source_vertex}); // marking the initial distance of source vertex as 0.",
				"shortest_distances[source_vertex] = 0;",
				"while (!pq.empty()){",
					"int curr_dist = pq.top().first;",
					"int curr_vertex = pq.top().second;",
					"pq.pop();",
					"for (auto j : adj_list[curr_vertex]){",
						"if (shortest_distances[j.first] > curr_dist + j.second){",
							"shortest_distances[j.first] = curr_dist + j.second;",
							"pq.push({shortest_distances[j.first], j.first});",
			"}}}}\n\n",

			"void eul_path_dir(vector<deque<ll>>& g, vll& ans){",
				"stack<ll> st;",
				"st.push(1);",
				"while(st.size()>0){",
					"int x=st.top();",
					"if(g[x].size()>0){",
						"int y=g[x][0];",
						"g[x].pop_front();",
						"st.push(y);",
					"}",
					"else{",
						"ans.emplace_back(x);",
						"st.pop();",
				"}}",
				"reverse(all(ans));",
			"}\n\n",

			"void fw(vector<vector<int>>& g, int n, int m, vector<vector<int>>& dp){",
				"// g[i] = {from, to, price}, n nodes 1 to n",
				"// dp -> (n+1)*(n+1) , initialised with 1e9",
				"for(int i=1; i<=n; i++) dp[i][i]=0;",
				"for(auto i:g){",
					"int f,t,p;",
					"f=i[0], t=i[1], p=i[2];",
					"dp[f][t]=p;",
				"}",
				"for(int k=1; k<=n; k++){",
					"for(int i=1; i<=n; i++){",
						"for(int j=1; j<=n; j++){",
							"dp[i][j]=(int)min((long long) dp[i][j], ((long long)dp[i][k]+(long long)dp[k][j]));",
			"}}}}\n\n",

			"void topo(vector<vll>& g, ll &n){",
				"vll ind(n+1,0);",
				"for(auto i:g){",
					"for(auto j:i){",
						"ind[j]++;",
				"}}",
				"queue<ll> q;",
				"fr(i,1,n+1) if(ind[i]==0) q.push(i);",
				"vll list;",
				"list.reserve(n);",
				"while(!q.empty()){",
					"ll x=q.front(); q.pop();",
					"list.emplace_back(x);",
					"for(auto j:g[x]){",
						"ind[j]--;",
						"if(ind[j]==0) q.push(j);",
			"}}}\n\n",

			"void dfs_scc(vector<vll>& g, ll i, ll &time, vll& vis, vll& disc_time, vll& finish_time){",
				"vis[i]=1;",
				"disc_time[i]=time;",
				"time++;",
				"for(auto j:g[i]){",
					"if(vis[j]==0)",
					"dfs_scc(g,j,time,vis,disc_time, finish_time);",
				"}",
				"finish_time[i]=time;",
				"time++;",
			"}\n",

			"ll scc(vector<vll>& g, vll& comp, ll& n){",
				"vll vis(n,0);",
				"vll discTime(n,0);",
				"vll finiTime(n,0);",
				"ll time=0;",
				"fr(i,0,n){",
					"if(vis[i]==0)",
					"dfs_scc(g, i, time, vis, discTime, finiTime);",
				"}",
				"vector<pll> fp(n);",
				"fr(i,0,n) fp[i]={finiTime[i], i};",
				"sort(all(fp), greater<pll>());",
				"vector<vll> gr(n);",
				"fr(i,0,n){",
					"for(auto j:g[i])",
					"gr[j].pb(i);",
				"}",
				"ll num=1;",
				"fill(all(vis), 0);",
				"for(auto i:fp){",
					"if(vis[i.sec]==1) continue;",
					"vis[i.sec]=1;",
					"comp[i.sec]=num;",
					"queue<ll> q;",
					"q.push(i.sec);",
					"while(!q.empty()){",
						"ll x=q.front(); q.pop();",
						"for(auto j:gr[x]){",
							"if(vis[j]==1) continue;",
							"vis[j]=1;",
							"comp[j]=num;",
							"q.push(j);",
					"}}",
					"num++;",
				"}",
				"return num-1;",
			"}\n\n\n",

			"void solve(){",
				"\tll n = nxt();",
				"\t$1",
			"}\n",


			"int main(){",
			"\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
			"\tll _ = nxt();",
			"\twhile (_--) solve();",
	 		"\treturn 0;",
			"}",
	 	],
	 	"description": "This is starting code for any program."
	 }
}
